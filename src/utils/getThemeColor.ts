// generated by claude 3.5 sonnet

type RGB = [number, number, number];
type ColorBox = {
  colors: Uint32Array;
  min: RGB;
  max: RGB;
};

export async function pickThemeColor(imageFile: File): Promise<RGB> {
  const imageData = await loadImageData(imageFile);
  const pixels = getPixels(imageData);
  const colorMap = quantizeColors(pixels, 5);
  return chooseBestColor(colorMap);
}

function loadImageData(imageFile: File): Promise<ImageData> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        reject(new Error("Unable to get 2D context"));
        return;
      }
      ctx.drawImage(img, 0, 0);
      resolve(ctx.getImageData(0, 0, img.width, img.height));
    };
    img.onerror = reject;
    img.src = URL.createObjectURL(imageFile);
  });
}

function getPixels(imageData: ImageData): Uint32Array {
  const pixels = new Uint32Array(imageData.width * imageData.height);
  const data = imageData.data;
  for (let i = 0, j = 0; i < data.length; i += 4, j++) {
    pixels[j] = (data[i] << 16) | (data[i + 1] << 8) | data[i + 2];
  }
  return pixels;
}

function quantizeColors(pixels: Uint32Array, colorCount: number): RGB[] {
  let colorBoxes: ColorBox[] = [
    {
      colors: pixels,
      min: [0, 0, 0],
      max: [255, 255, 255],
    },
  ];

  while (colorBoxes.length < colorCount) {
    let boxToSplit = colorBoxes.reduce((a, b) =>
      getVolume(a) > getVolume(b) ? a : b,
    );
    const index = colorBoxes.indexOf(boxToSplit);
    const [box1, box2] = splitColorBox(boxToSplit);
    colorBoxes[index] = box1;
    colorBoxes.push(box2);
  }

  return colorBoxes.map(averageColor);
}

function getVolume(box: ColorBox): number {
  const { min, max } = box;
  return (max[0] - min[0] + 1) * (max[1] - min[1] + 1) * (max[2] - min[2] + 1);
}

function splitColorBox(box: ColorBox): [ColorBox, ColorBox] {
  const { colors, min, max } = box;
  const longestSideIndex = getLongestSideIndex(min, max);
  const midPoint = Math.floor(
    (min[longestSideIndex] + max[longestSideIndex]) / 2,
  );

  const left: number[] = [];
  const right: number[] = [];

  for (let i = 0; i < colors.length; i++) {
    const color = colors[i];
    const component = (color >> (8 * (2 - longestSideIndex))) & 0xff;
    if (component <= midPoint) {
      left.push(color);
    } else {
      right.push(color);
    }
  }

  const leftBox: ColorBox = {
    colors: new Uint32Array(left),
    min: [...min] as RGB,
    max: [...max] as RGB,
  };
  leftBox.max[longestSideIndex] = midPoint;

  const rightBox: ColorBox = {
    colors: new Uint32Array(right),
    min: [...min] as RGB,
    max: [...max] as RGB,
  };
  rightBox.min[longestSideIndex] = midPoint + 1;

  return [leftBox, rightBox];
}

function getLongestSideIndex(min: RGB, max: RGB): number {
  const lengths = max.map((v, i) => v - min[i]);
  return lengths.indexOf(Math.max(...lengths));
}

function averageColor(box: ColorBox): RGB {
  let r = 0,
    g = 0,
    b = 0;
  const { colors } = box;
  for (let i = 0; i < colors.length; i++) {
    const color = colors[i];
    r += (color >> 16) & 0xff;
    g += (color >> 8) & 0xff;
    b += color & 0xff;
  }
  const count = colors.length;
  return [Math.round(r / count), Math.round(g / count), Math.round(b / count)];
}

function chooseBestColor(palette: RGB[]): RGB {
  return palette.reduce(
    (best, color) => {
      const saturation = getSaturation(color);
      const brightness = getBrightness(color);
      const score = saturation + (1 - Math.abs(brightness - 0.5));
      return score > best.score ? { color, score } : best;
    },
    { color: palette[0], score: -Infinity },
  ).color;
}

function getSaturation(rgb: RGB): number {
  const [r, g, b] = rgb;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  return max === 0 ? 0 : (max - min) / max;
}

function getBrightness(rgb: RGB): number {
  const [r, g, b] = rgb;
  return (r * 299 + g * 587 + b * 114) / 255000;
}

export default pickThemeColor;
