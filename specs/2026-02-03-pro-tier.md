# Pro Tier Subscription System

**Status**: draft

## Goal

Add a paid Pro tier to Leaflet using Stripe for billing, with an entitlements-based architecture that decouples feature access from subscription state.

## Design

### Data Model

Two new tables separate Stripe subscription state from feature access:

**`user_subscriptions`** — Stripe sync state
- `identity_id` (UUID, FK to identities, PK)
- `stripe_customer_id` (text, unique)
- `stripe_subscription_id` (text, unique, nullable)
- `plan` (text) — Price ID from `stripe/products.ts`, e.g., `pro_monthly_v1_usd`
- `status` (text) — mirrors Stripe: `trialing`, `active`, `past_due`, `canceled`, `unpaid`
- `current_period_end` (timestamp)
- `created_at`, `updated_at`

**`user_entitlements`** — Feature access grants
- `identity_id` (UUID, FK to identities)
- `entitlement_key` (text) — e.g., `analytics`
- `granted_at` (timestamp)
- `expires_at` (timestamp, nullable) — null means permanent
- `source` (text) — provenance, e.g., `stripe:sub_xxx`, `manual:admin`, `promo:launch2026`
- `metadata` (jsonb, nullable) — for limits or additional config
- Primary key: `(identity_id, entitlement_key)` — one entitlement per key per user

The unique constraint on `(identity_id, entitlement_key)` means writes are upserts. The most recent write wins; `source` tracks provenance.

### SKU → Entitlements Mapping

Entitlements for each Stripe Product are stored in Stripe's product metadata, not locally. Example product metadata:

```json
{
  "entitlements": "{\"analytics\": true}"
}
```

This keeps Stripe as the source of truth for what each SKU grants.

### Stripe Product Sync

Products and prices are defined in code and synced to Stripe via a GitHub Action. This provides version control, reproducibility, and enforces immutability.

**Directory structure:**
```
stripe/
├── products.ts          # Product/price definitions with entitlement metadata
└── sync.ts              # Script that ensures Stripe matches definitions
```

**Product definition format** (`stripe/products.ts`):
```typescript
export const products = [
  {
    id: "pro_monthly_v1",
    name: "Leaflet Pro (Monthly)",
    prices: [
      {
        id: "pro_monthly_v1_usd",
        currency: "usd",
        unit_amount: 900, // $9.00
        recurring: { interval: "month" },
      },
    ],
    metadata: {
      entitlements: JSON.stringify({ publication_analytics: true }),
    },
  },
];
```

**Sync script behavior** (`stripe/sync.ts`):
1. Fetch existing products and prices by `id` (`stripe.products.retrieve(id)`, `stripe.prices.retrieve(id)`)
2. For each definition:
   - If missing in Stripe → create it with the custom `id`
   - If exists and matches → no-op
   - If exists but differs → update it to match the definition
3. Never deletes products/prices

Both products and prices use custom `id` for idempotent matching (set at creation). Same definitions apply to both test and live mode—the script targets whichever mode the API key belongs to.

**GitHub Action** (`.github/workflows/stripe-sync.yml`):
- Triggers on push to `stripe/` directory
- Runs sync against test mode automatically
- Live mode sync requires manual workflow dispatch with approval

**Versioning/grandfathering:**
To grandfather existing subscribers on different terms, create a new product with a new `id` (e.g., `pro_monthly_v2`). Existing subscribers stay on v1. New subscribers get v2. For additive changes (new entitlements, metadata updates), just update the existing product definition.

### Stripe Sync Strategy

**Webhook-driven** with **optimistic updates**:

1. **Optimistic**: After successful Checkout Session completion on the client, immediately call a server action to write `user_subscriptions` and `user_entitlements` based on the session data. User gets instant access.

2. **Durable**: Stripe webhooks confirm and reconcile state. Handles edge cases (payment failures, disputes, subscription updates from Stripe dashboard).

Webhooks to handle:
- `checkout.session.completed` — initial subscription created
- `customer.subscription.created` — backup for subscription creation
- `customer.subscription.updated` — plan changes, renewals, status changes
- `customer.subscription.deleted` — subscription ended
- `invoice.payment_failed` — payment issues
- `customer.subscription.trial_will_end` — trial ending reminder (optional, for notifications)

### Entitlement Lifecycle

**Grant flow** (subscription activates or trial starts):
1. Webhook receives event with subscription and product data
2. Parse `entitlements` from product metadata
3. Upsert `user_entitlements` rows with `expires_at` = `current_period_end`, `source` = `stripe:{subscription_id}`

**Renewal flow** (subscription renews):
1. `customer.subscription.updated` webhook fires
2. Update `expires_at` on all entitlements with matching `source`

**Cancellation flow** (user cancels but period remains):
1. `customer.subscription.updated` with `cancel_at_period_end: true`
2. Update `user_subscriptions.status`
3. Entitlements remain valid until `expires_at` (already set to period end)

**Expiration flow** (subscription ends):
1. `customer.subscription.deleted` webhook fires
2. No action needed on `user_entitlements` — they naturally expire via `expires_at`
3. Update `user_subscriptions.status` to `canceled`

Soft expiration via `expires_at` preserves audit history and handles the canceled-but-paid-through-period case without additional webhooks.

### Trials

Stripe-managed trials:
1. Trial starts → subscription created with `status: trialing`
2. Entitlements granted with `expires_at` = trial end date
3. Trial converts → `expires_at` updated to subscription period end
4. Trial lapses → entitlements expire naturally, no action needed

### Entitlement Checks

Extend `getIdentityData()` to join against `user_entitlements` and return active entitlements:

```typescript
type IdentityData = {
  id: string;
  email: string;
  atp_did: string;
  // ... existing fields
  entitlements: Record<string, {
    granted_at: string;
    expires_at: string | null;
    source: string;
    metadata: Record<string, unknown> | null;
  }>;
};
```

Query filters to `expires_at IS NULL OR expires_at > NOW()`. The `useIdentityData()` hook exposes the same shape client-side.

Feature gating in server actions:

```typescript
export async function getAnalyticsData() {
  const identity = await getIdentityData();
  if (!identity?.entitlements.analytics) {
    return err("Pro subscription required");
  }
  // ... fetch analytics
}
```

### Initial Pro Features

Single entitlement at launch:
- `publication_analytics` (boolean) — access to analytics features for
  publications

### Webhook Endpoint

New API route at `app/api/webhooks/stripe/route.ts`:
- Verify Stripe signature using `STRIPE_WEBHOOK_SECRET`
- Dispatch to Inngest functions for processing (keeps webhook response fast, enables retries)

### Inngest Functions

New functions in `app/api/inngest/functions/`:
- `stripe/handle-checkout-completed` — process successful checkout
- `stripe/handle-subscription-updated` — sync subscription changes to entitlements
- `stripe/handle-subscription-deleted` — update subscription status

Events to add to Inngest client:
```typescript
"stripe/checkout.session.completed": { data: { sessionId: string } }
"stripe/customer.subscription.updated": { data: { subscriptionId: string } }
"stripe/customer.subscription.deleted": { data: { subscriptionId: string } }
```

### Environment Variables

```
STRIPE_SECRET_KEY=sk_...
STRIPE_WEBHOOK_SECRET=whsec_...
```

Price IDs are defined in `stripe/products.ts` and imported directly — no env var needed.

## Open Questions

- **UI**: Where upgrade prompts appear, pricing page design, checkout flow UX — to be designed separately
- **Multiple plans**: Current design supports one subscription per user. If we add team plans or multiple concurrent subscriptions, `user_subscriptions` would need to become one-to-many

## Implementation

1. **Add Stripe packages**: Install `stripe` npm package

2. **Database migration**: Create `user_subscriptions` and `user_entitlements` tables with indexes on `identity_id` and `expires_at`

3. **Drizzle schema**: Add table definitions to `drizzle/schema.ts`

4. **Environment setup**: Add Stripe env vars to `.env.local` and deployment config

5. **Stripe webhook endpoint**: Create `app/api/webhooks/stripe/route.ts` with signature verification, dispatch events to Inngest

6. **Inngest events and functions**: Add event types to `app/api/inngest/client.ts`, create handler functions for checkout completed, subscription updated, subscription deleted

7. **Extend getIdentityData**: Join against `user_entitlements`, filter expired, return entitlements object

8. **Extend useIdentityData**: Ensure client-side hook receives entitlements from server

9. **Optimistic update action**: Create `actions/subscriptions/activateSubscription.ts` for immediate access after checkout

10. **Stripe sync infrastructure**:
    - Create `stripe/products.ts` with Pro product definitions and entitlement metadata
    - Create `stripe/sync.ts` script using Stripe Node SDK to reconcile definitions with Stripe
    - Add `.github/workflows/stripe-sync.yml` for automated test mode sync on push, manual live mode sync

11. **Initial product sync**: Run sync script against both test and live mode to create Pro products

12. **Gate analytics**: Add entitlement check to analytics server actions
